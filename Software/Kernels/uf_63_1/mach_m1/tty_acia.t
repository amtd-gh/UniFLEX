 lib environment.h lib ../include/acia.h lib ../include/tty.h data sttl ACIA interface routines pag name tty_acia global ttconf,ttputc,ttgetc,ttenxr,ttdisx,ttenr,ttenx,ttenno global ttxbsy,tttstx,tttstr,tttstb,tttstc,tttste,ttend,ttsbrg global tty_acia,ttiscts,ttwcts,ttwdcd,tttsts global AWORDtty_acia equ $0001* The routines in this file are specific to an ACIA (6850).* They are called from the "ttyhan" and "ttydrv" files.** ttconf** Configure the port pointed at by the Y register.  The X* register is pointing to the terminal table.  All registers* except D should be preserved.*ttconf lda #3 reset the acia sta csr,y pshs d delay some here puls d lda csr,y get status - see if acia is really here beq 2f if 0 status - then ok bita #$f3 see if funny status is ok bne 4f2 lda tbaud,x get configuration word from table ora #ADIVID set up full configuration sta csr,y (no ints enabled & RTS brought high) lda csr,y get new status bita #$8 is CTS ok? beq 6f4 sez set false status clc show wait for CTS rts return6 clz set true status rts return** ttputc** Send the character in the B register to the ACIA.  All* registers should be preserved.  Y points to the device.*ttputc stb dbuf,y send character rts return** ttgetc** Get the character from the device and return in the B* register.  Y points to the device and all registers* should be preserved.*ttgetc ldb dbuf,y get the character rts return** ttenxr** Enable the transmit interrupts and leave the receive* interrupt enabled (it is enabled upon routine entry).* Y points to the device and X points to to the terminal* table entry.  Preserve all registers but D.**ttenxr lda tbaud,x get configuration ora #ENBXIN|ADIVID|ENBRIN enable int bits sta csr,y send to acia rts return** ttdisx** Disable the transmit interrupt and leave the receive* interrupt enabled.  Y points to the device and X points* to the terminal table entry.  Preserve all but D.*ttdisx lda tbaud,x get configuration word ora #ADIVID|ENBRIN|DSBXIN set bits sta csr,y send to acia rts return** ttenr** Enable the receive interrupts only.  The transmit* interrupts should be turned off.  Y points to the device* and X point to the terminal table entry.  Preserve all* but the D register.*ttenr lda tbaud,x get configuration word ora #ADIVID|ENBRIN|DSBXIN set bits sta csr,y send to acia rts return** ttenx** Enable the transmit interrupts only.  The receive* interrupts should be left disabled.  Y points to the* device and X points to the terminal table entry.* All registers but D shoud be preserved.*ttenx lda tbaud,x get configuration word ora #ADIVID|ENBXIN set bits sta csr,y send to acia rts return** ttenno** Disable all interrupts from device and drop the RTS* line.  Y points to the device and X points to the* terminal table entry.  Preserve all but D register.*ttenno lda tbaud,x get configuration word ora #ADIVID|$40 set bits sta csr,y send to acia rts return** ttxbsy** Test if the transmit buffer is empty.  Return TRUE if* it is empty (N.E. status). Y points to the device and* all but A needs preserved.*ttxbsy lda csr,y get status bita #ACTBSY is it busy? rts return** tttstx** Test device pointed at by Y for a transmit interrupt.* Return TRUE if interrupt present.  Preserve all but* the A register.*tttstx lda csr,y get status bita #ACRBSY|$04 bne false bra true** ttiscts** Test device pointed at by X for "Clear to Send"* -- Return TRUE (not equal) if yes*ttiscts lda csr,x check for CTS bita #$8 is CTS down? bne falsetrue clz no - return TRUE rtsfalse sez yes - return FALSE rts** tttstr** Test device pointed at by Y for a receive interrupt.* Return TRUE if interrupt present.  Preserve all but* the A register.*tttstr bita #%00110100 check status bne false bra true** tttstb** Test device pointed at by Y for a "break" condition.* Return TRUE if found.  Preserve all registers but A* and return NULL in B (for break character).*tttstb bita #$30 check for break condition beq 2f ldb dbuf,y get character from acia pshs d,x,y,u delay some here puls d,x,y,u lda dbuf,y get next garbage char if any clz set true2 rts return** tttsts** Test device for "CTS" interrupt.*tttsts bra false not currently implemented** tttstc** Test device pointed at by Y for drop "Carrier Detect"* type interrupt.  Return TRUE if so.  Preserve all registers* but A.*tttstc bita #$04 check for carrier drop beq 1f jump if no error ldb dbuf,y read reg to reset status clz return true1 rts return** tttste** Test device pointed at by Y for error conditions.* Handle all errors local to this routine - no status* returned.  Preserve all but A.*tttste lda dbuf,y read data register to clear any interrupt conditions clz return true rts return** ttend** Terminate i/o operation for device pointed at by Y.* Preserve all but D.*ttend rts return (nothing for acia)** ttsbrg** Set up the baud rate generators - if any.  On entry,* Y points to xmit BRG and U points to rcvr BRG.  X is* pointing to the terminal table entry (tbaud2,x has* byte for baud rate generator).*ttsbrg lda tbaud2,x get speed byte sta 0,y set xmit speed sta 0,u set rcvr speed rts return** ttwcts** Wait for CTS to go high (sleep on it).*ttwcts bsr ttenx enable xmit ints only ldb #TTYOPR set priority ldy tqout,x point to output q jmp sleep sleep on CTS** ttwdcd** Wait for DCD to go high (sleep on it).*ttwdcd rts currently not implemented